---
data:
  _extendedDependsOn: []
  _extendedRequiredBy:
  - icon: ':heavy_check_mark:'
    path: graph/chromatic.hpp
    title: graph/chromatic.hpp
  - icon: ':heavy_check_mark:'
    path: graph/count/count_labeled_biconnected.hpp
    title: graph/count/count_labeled_biconnected.hpp
  - icon: ':heavy_check_mark:'
    path: graph/count/count_labeled_bridgeless.hpp
    title: graph/count/count_labeled_bridgeless.hpp
  - icon: ':heavy_check_mark:'
    path: linalg/blackbox/vandermonde.hpp
    title: linalg/blackbox/vandermonde.hpp
  - icon: ':heavy_check_mark:'
    path: poly/composition.hpp
    title: poly/composition.hpp
  - icon: ':heavy_check_mark:'
    path: poly/composition_f_log_1_minus_x.hpp
    title: poly/composition_f_log_1_minus_x.hpp
  - icon: ':heavy_check_mark:'
    path: poly/compositional_inverse.hpp
    title: poly/compositional_inverse.hpp
  - icon: ':heavy_check_mark:'
    path: poly/multipoint.hpp
    title: poly/multipoint.hpp
  - icon: ':heavy_check_mark:'
    path: poly/multivar_convolution_cyclic.hpp
    title: poly/multivar_convolution_cyclic.hpp
  - icon: ':heavy_check_mark:'
    path: poly/partial_frac_decomposition_1.hpp
    title: poly/partial_frac_decomposition_1.hpp
  - icon: ':heavy_check_mark:'
    path: poly/slice_rational_fps.hpp
    title: poly/slice_rational_fps.hpp
  _extendedVerifiedWith:
  - icon: ':heavy_check_mark:'
    path: test/1_mytest/chirp_z.test.cpp
    title: test/1_mytest/chirp_z.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/1_mytest/composition_1_minus_ex.test.cpp
    title: test/1_mytest/composition_1_minus_ex.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/1_mytest/composition_ex_minus_1.test.cpp
    title: test/1_mytest/composition_ex_minus_1.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/1_mytest/composition_log_1_minus_x.test.cpp
    title: test/1_mytest/composition_log_1_minus_x.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/1_mytest/compositional_inverset.test.cpp
    title: test/1_mytest/compositional_inverset.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/1_mytest/count_labeled_biconnected.test.cpp
    title: test/1_mytest/count_labeled_biconnected.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/1_mytest/count_labeled_bridgeless.test.cpp
    title: test/1_mytest/count_labeled_bridgeless.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/1_mytest/partial_frac.test.cpp
    title: test/1_mytest/partial_frac.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/1_mytest/vandermonde.test.cpp
    title: test/1_mytest/vandermonde.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/2_library_checker/graph/chromatic_number.test.cpp
    title: test/2_library_checker/graph/chromatic_number.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/2_library_checker/graph/chromatic_polynomial.test.cpp
    title: test/2_library_checker/graph/chromatic_polynomial.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/2_library_checker/math/multivariate_convolution_cyclic.test.cpp
    title: test/2_library_checker/math/multivariate_convolution_cyclic.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/2_library_checker/polynomial/composition_dmint.test.cpp
    title: test/2_library_checker/polynomial/composition_dmint.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/2_library_checker/polynomial/composition_of_fps.test.cpp
    title: test/2_library_checker/polynomial/composition_of_fps.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/2_library_checker/polynomial/compositional_inverse.test.cpp
    title: test/2_library_checker/polynomial/compositional_inverse.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/2_library_checker/polynomial/compositional_inverse_dmint.test.cpp
    title: test/2_library_checker/polynomial/compositional_inverse_dmint.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/2_library_checker/polynomial/multipoint_evaluation.test.cpp
    title: test/2_library_checker/polynomial/multipoint_evaluation.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/2_library_checker/polynomial/multipoint_evaluation_on_geom.test.cpp
    title: test/2_library_checker/polynomial/multipoint_evaluation_on_geom.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/2_library_checker/polynomial/multipoint_evaluation_on_geom_2.test.cpp
    title: test/2_library_checker/polynomial/multipoint_evaluation_on_geom_2.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/2_library_checker/polynomial/polynomial_interpolation.test.cpp
    title: test/2_library_checker/polynomial/polynomial_interpolation.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/2_library_checker/polynomial/polynomial_interpolation_on_geom.test.cpp
    title: test/2_library_checker/polynomial/polynomial_interpolation_on_geom.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/2_library_checker/polynomial/slice_rational.test.cpp
    title: test/2_library_checker/polynomial/slice_rational.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/3_yukicoder/1575.test.cpp
    title: test/3_yukicoder/1575.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/3_yukicoder/2166.test.cpp
    title: test/3_yukicoder/2166.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/3_yukicoder/2243.test.cpp
    title: test/3_yukicoder/2243.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/5_atcoder/abc241h.test.cpp
    title: test/5_atcoder/abc241h.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/5_atcoder/abc260h.test.cpp
    title: test/5_atcoder/abc260h.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/5_atcoder/abc267g.test.cpp
    title: test/5_atcoder/abc267g.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/5_atcoder/abc272_h.test.cpp
    title: test/5_atcoder/abc272_h.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/5_atcoder/agc013e.test.cpp
    title: test/5_atcoder/agc013e.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/5_atcoder/agc058d2.test.cpp
    title: test/5_atcoder/agc058d2.test.cpp
  _isVerificationFailed: false
  _pathExtension: hpp
  _verificationStatusIcon: ':heavy_check_mark:'
  attributes:
    links: []
  bundledCode: "#line 2 \"poly/transposed_ntt.hpp\"\n\ntemplate <class mint>\nvoid\
    \ transposed_ntt(vector<mint>& a, bool inverse) {\n  assert(mint::can_ntt());\n\
    \  const int rank2 = mint::ntt_info().fi;\n  const int mod = mint::get_mod();\n\
    \  static array<mint, 30> root, iroot;\n  static array<mint, 30> rate2, irate2;\n\
    \  static array<mint, 30> rate3, irate3;\n\n  assert(rank2 != -1 && len(a) <=\
    \ (1 << max(0, rank2)));\n\n  static bool prepared = 0;\n  if (!prepared) {\n\
    \    prepared = 1;\n    root[rank2] = mint::ntt_info().se;\n    iroot[rank2] =\
    \ mint(1) / root[rank2];\n    FOR_R(i, rank2) {\n      root[i] = root[i + 1] *\
    \ root[i + 1];\n      iroot[i] = iroot[i + 1] * iroot[i + 1];\n    }\n    mint\
    \ prod = 1, iprod = 1;\n    for (int i = 0; i <= rank2 - 2; i++) {\n      rate2[i]\
    \ = root[i + 2] * prod;\n      irate2[i] = iroot[i + 2] * iprod;\n      prod *=\
    \ iroot[i + 2];\n      iprod *= root[i + 2];\n    }\n    prod = 1, iprod = 1;\n\
    \    for (int i = 0; i <= rank2 - 3; i++) {\n      rate3[i] = root[i + 3] * prod;\n\
    \      irate3[i] = iroot[i + 3] * iprod;\n      prod *= iroot[i + 3];\n      iprod\
    \ *= root[i + 3];\n    }\n  }\n\n  int n = int(a.size());\n  int h = topbit(n);\n\
    \  assert(n == 1 << h);\n  if (!inverse) {\n    int len = h;\n    while (len >\
    \ 0) {\n      if (len == 1) {\n        int p = 1 << (h - len);\n        mint rot\
    \ = 1;\n        FOR(s, 1 << (len - 1)) {\n          int offset = s << (h - len\
    \ + 1);\n          FOR(i, p) {\n            u64 l = a[i + offset].val;\n     \
    \       u64 r = a[i + offset + p].val;\n            a[i + offset] = l + r;\n \
    \           a[i + offset + p] = (mod + l - r) * rot.val;\n          }\n      \
    \    rot *= rate2[topbit(~s & -~s)];\n        }\n        len--;\n      } else\
    \ {\n        int p = 1 << (h - len);\n        mint rot = 1, imag = root[2];\n\
    \        FOR(s, (1 << (len - 2))) {\n          int offset = s << (h - len + 2);\n\
    \          mint rot2 = rot * rot;\n          mint rot3 = rot2 * rot;\n       \
    \   for (int i = 0; i < p; i++) {\n            u64 a0 = a[i + offset + 0 * p].val;\n\
    \            u64 a1 = a[i + offset + 1 * p].val;\n            u64 a2 = a[i + offset\
    \ + 2 * p].val;\n            u64 a3 = a[i + offset + 3 * p].val;\n           \
    \ u64 x = (mod + a2 - a3) * imag.val % mod;\n            a[i + offset] = a0 +\
    \ a1 + a2 + a3;\n            a[i + offset + 1 * p] = (a0 + mod - a1 + x) * rot.val;\n\
    \            a[i + offset + 2 * p] = (a0 + a1 + 2 * mod - a2 - a3) * rot2.val;\n\
    \            a[i + offset + 3 * p] = (a0 + 2 * mod - a1 - x) * rot3.val;\n   \
    \       }\n          rot *= rate3[topbit(~s & -~s)];\n        }\n        len -=\
    \ 2;\n      }\n    }\n  } else {\n    mint coef = mint(1) / mint(len(a));\n  \
    \  FOR(i, len(a)) a[i] *= coef;\n    int len = 0;\n    while (len < h) {\n   \
    \   if (len == h - 1) {\n        int p = 1 << (h - len - 1);\n        mint irot\
    \ = 1;\n        FOR(s, 1 << len) {\n          int offset = s << (h - len);\n \
    \         FOR(i, p) {\n            auto l = a[i + offset];\n            auto r\
    \ = a[i + offset + p] * irot;\n            a[i + offset] = l + r;\n          \
    \  a[i + offset + p] = l - r;\n          }\n          irot *= irate2[topbit(~s\
    \ & -~s)];\n        }\n        len++;\n      } else {\n        int p = 1 << (h\
    \ - len - 2);\n        mint irot = 1, iimag = iroot[2];\n        for (int s =\
    \ 0; s < (1 << len); s++) {\n          mint irot2 = irot * irot;\n          mint\
    \ irot3 = irot2 * irot;\n          int offset = s << (h - len);\n          for\
    \ (int i = 0; i < p; i++) {\n            u64 mod2 = u64(mod) * mod;\n        \
    \    u64 a0 = a[i + offset].val;\n            u64 a1 = u64(a[i + offset + p].val)\
    \ * irot.val;\n            u64 a2 = u64(a[i + offset + 2 * p].val) * irot2.val;\n\
    \            u64 a3 = u64(a[i + offset + 3 * p].val) * irot3.val;\n          \
    \  u64 a1na3imag = (a1 + mod2 - a3) % mod * iimag.val;\n            u64 na2 =\
    \ mod2 - a2;\n            a[i + offset] = a0 + a2 + a1 + a3;\n            a[i\
    \ + offset + 1 * p] = a0 + a2 + (2 * mod2 - (a1 + a3));\n            a[i + offset\
    \ + 2 * p] = a0 + na2 + a1na3imag;\n            a[i + offset + 3 * p] = a0 + na2\
    \ + (mod2 - a1na3imag);\n          }\n          irot *= irate3[topbit(~s & -~s)];\n\
    \        }\n        len += 2;\n      }\n    }\n  }\n}\n"
  code: "#pragma once\n\ntemplate <class mint>\nvoid transposed_ntt(vector<mint>&\
    \ a, bool inverse) {\n  assert(mint::can_ntt());\n  const int rank2 = mint::ntt_info().fi;\n\
    \  const int mod = mint::get_mod();\n  static array<mint, 30> root, iroot;\n \
    \ static array<mint, 30> rate2, irate2;\n  static array<mint, 30> rate3, irate3;\n\
    \n  assert(rank2 != -1 && len(a) <= (1 << max(0, rank2)));\n\n  static bool prepared\
    \ = 0;\n  if (!prepared) {\n    prepared = 1;\n    root[rank2] = mint::ntt_info().se;\n\
    \    iroot[rank2] = mint(1) / root[rank2];\n    FOR_R(i, rank2) {\n      root[i]\
    \ = root[i + 1] * root[i + 1];\n      iroot[i] = iroot[i + 1] * iroot[i + 1];\n\
    \    }\n    mint prod = 1, iprod = 1;\n    for (int i = 0; i <= rank2 - 2; i++)\
    \ {\n      rate2[i] = root[i + 2] * prod;\n      irate2[i] = iroot[i + 2] * iprod;\n\
    \      prod *= iroot[i + 2];\n      iprod *= root[i + 2];\n    }\n    prod = 1,\
    \ iprod = 1;\n    for (int i = 0; i <= rank2 - 3; i++) {\n      rate3[i] = root[i\
    \ + 3] * prod;\n      irate3[i] = iroot[i + 3] * iprod;\n      prod *= iroot[i\
    \ + 3];\n      iprod *= root[i + 3];\n    }\n  }\n\n  int n = int(a.size());\n\
    \  int h = topbit(n);\n  assert(n == 1 << h);\n  if (!inverse) {\n    int len\
    \ = h;\n    while (len > 0) {\n      if (len == 1) {\n        int p = 1 << (h\
    \ - len);\n        mint rot = 1;\n        FOR(s, 1 << (len - 1)) {\n         \
    \ int offset = s << (h - len + 1);\n          FOR(i, p) {\n            u64 l =\
    \ a[i + offset].val;\n            u64 r = a[i + offset + p].val;\n           \
    \ a[i + offset] = l + r;\n            a[i + offset + p] = (mod + l - r) * rot.val;\n\
    \          }\n          rot *= rate2[topbit(~s & -~s)];\n        }\n        len--;\n\
    \      } else {\n        int p = 1 << (h - len);\n        mint rot = 1, imag =\
    \ root[2];\n        FOR(s, (1 << (len - 2))) {\n          int offset = s << (h\
    \ - len + 2);\n          mint rot2 = rot * rot;\n          mint rot3 = rot2 *\
    \ rot;\n          for (int i = 0; i < p; i++) {\n            u64 a0 = a[i + offset\
    \ + 0 * p].val;\n            u64 a1 = a[i + offset + 1 * p].val;\n           \
    \ u64 a2 = a[i + offset + 2 * p].val;\n            u64 a3 = a[i + offset + 3 *\
    \ p].val;\n            u64 x = (mod + a2 - a3) * imag.val % mod;\n           \
    \ a[i + offset] = a0 + a1 + a2 + a3;\n            a[i + offset + 1 * p] = (a0\
    \ + mod - a1 + x) * rot.val;\n            a[i + offset + 2 * p] = (a0 + a1 + 2\
    \ * mod - a2 - a3) * rot2.val;\n            a[i + offset + 3 * p] = (a0 + 2 *\
    \ mod - a1 - x) * rot3.val;\n          }\n          rot *= rate3[topbit(~s & -~s)];\n\
    \        }\n        len -= 2;\n      }\n    }\n  } else {\n    mint coef = mint(1)\
    \ / mint(len(a));\n    FOR(i, len(a)) a[i] *= coef;\n    int len = 0;\n    while\
    \ (len < h) {\n      if (len == h - 1) {\n        int p = 1 << (h - len - 1);\n\
    \        mint irot = 1;\n        FOR(s, 1 << len) {\n          int offset = s\
    \ << (h - len);\n          FOR(i, p) {\n            auto l = a[i + offset];\n\
    \            auto r = a[i + offset + p] * irot;\n            a[i + offset] = l\
    \ + r;\n            a[i + offset + p] = l - r;\n          }\n          irot *=\
    \ irate2[topbit(~s & -~s)];\n        }\n        len++;\n      } else {\n     \
    \   int p = 1 << (h - len - 2);\n        mint irot = 1, iimag = iroot[2];\n  \
    \      for (int s = 0; s < (1 << len); s++) {\n          mint irot2 = irot * irot;\n\
    \          mint irot3 = irot2 * irot;\n          int offset = s << (h - len);\n\
    \          for (int i = 0; i < p; i++) {\n            u64 mod2 = u64(mod) * mod;\n\
    \            u64 a0 = a[i + offset].val;\n            u64 a1 = u64(a[i + offset\
    \ + p].val) * irot.val;\n            u64 a2 = u64(a[i + offset + 2 * p].val) *\
    \ irot2.val;\n            u64 a3 = u64(a[i + offset + 3 * p].val) * irot3.val;\n\
    \            u64 a1na3imag = (a1 + mod2 - a3) % mod * iimag.val;\n           \
    \ u64 na2 = mod2 - a2;\n            a[i + offset] = a0 + a2 + a1 + a3;\n     \
    \       a[i + offset + 1 * p] = a0 + a2 + (2 * mod2 - (a1 + a3));\n          \
    \  a[i + offset + 2 * p] = a0 + na2 + a1na3imag;\n            a[i + offset + 3\
    \ * p] = a0 + na2 + (mod2 - a1na3imag);\n          }\n          irot *= irate3[topbit(~s\
    \ & -~s)];\n        }\n        len += 2;\n      }\n    }\n  }\n}\n"
  dependsOn: []
  isVerificationFile: false
  path: poly/transposed_ntt.hpp
  requiredBy:
  - graph/chromatic.hpp
  - graph/count/count_labeled_bridgeless.hpp
  - graph/count/count_labeled_biconnected.hpp
  - poly/multipoint.hpp
  - poly/composition.hpp
  - poly/compositional_inverse.hpp
  - poly/partial_frac_decomposition_1.hpp
  - poly/multivar_convolution_cyclic.hpp
  - poly/composition_f_log_1_minus_x.hpp
  - poly/slice_rational_fps.hpp
  - linalg/blackbox/vandermonde.hpp
  timestamp: '2024-04-23 20:14:58+09:00'
  verificationStatus: LIBRARY_ALL_AC
  verifiedWith:
  - test/5_atcoder/abc241h.test.cpp
  - test/5_atcoder/abc260h.test.cpp
  - test/5_atcoder/agc013e.test.cpp
  - test/5_atcoder/abc272_h.test.cpp
  - test/5_atcoder/agc058d2.test.cpp
  - test/5_atcoder/abc267g.test.cpp
  - test/3_yukicoder/2166.test.cpp
  - test/3_yukicoder/1575.test.cpp
  - test/3_yukicoder/2243.test.cpp
  - test/2_library_checker/polynomial/composition_dmint.test.cpp
  - test/2_library_checker/polynomial/multipoint_evaluation_on_geom.test.cpp
  - test/2_library_checker/polynomial/multipoint_evaluation_on_geom_2.test.cpp
  - test/2_library_checker/polynomial/composition_of_fps.test.cpp
  - test/2_library_checker/polynomial/polynomial_interpolation.test.cpp
  - test/2_library_checker/polynomial/slice_rational.test.cpp
  - test/2_library_checker/polynomial/compositional_inverse_dmint.test.cpp
  - test/2_library_checker/polynomial/compositional_inverse.test.cpp
  - test/2_library_checker/polynomial/polynomial_interpolation_on_geom.test.cpp
  - test/2_library_checker/polynomial/multipoint_evaluation.test.cpp
  - test/2_library_checker/graph/chromatic_number.test.cpp
  - test/2_library_checker/graph/chromatic_polynomial.test.cpp
  - test/2_library_checker/math/multivariate_convolution_cyclic.test.cpp
  - test/1_mytest/composition_ex_minus_1.test.cpp
  - test/1_mytest/compositional_inverset.test.cpp
  - test/1_mytest/count_labeled_bridgeless.test.cpp
  - test/1_mytest/composition_log_1_minus_x.test.cpp
  - test/1_mytest/partial_frac.test.cpp
  - test/1_mytest/composition_1_minus_ex.test.cpp
  - test/1_mytest/count_labeled_biconnected.test.cpp
  - test/1_mytest/vandermonde.test.cpp
  - test/1_mytest/chirp_z.test.cpp
documentation_of: poly/transposed_ntt.hpp
layout: document
redirect_from:
- /library/poly/transposed_ntt.hpp
- /library/poly/transposed_ntt.hpp.html
title: poly/transposed_ntt.hpp
---
